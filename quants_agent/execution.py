from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Tuple
import random
from quants_agent.events import FillEvent


class ExecutionHandler(ABC):
    """
    The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market.
    """

    @abstractmethod
    def execute_order(self, event: Any) -> None:
        """
        Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.
        """
        raise NotImplementedError


class SimulatedExecutionHandler(ExecutionHandler):
    """
    The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    It allows a "Trailing Stop" which is simulated by tracking data updates.
    """

    def __init__(self, events: Any, bars: Any, config: Any):
        self.events = events
        self.bars = bars
        self.config = config

        # Store conditional orders: { order_id: { 'symbol':..., 'type':..., 'trigger_price':..., 'parent_id':...} }
        # For simplicity, just list of order dicts
        self.active_orders: List[Dict[str, Any]] = []

    def _apply_slippage_and_comm(
        self, price: float, quantity: float, direction: str, symbol: str
    ) -> Tuple[float, float]:
        """
        Helper to apply physics (Slippage/Fees/Spread) to a raw price.
        """
        # 1. Variable Slippage Model
        slippage_bps = random.uniform(0.0001, 0.0005)  # 1bps to 5bps

        # Volatility scale
        high = self.bars.get_latest_bar_value(symbol, "high")
        low = self.bars.get_latest_bar_value(symbol, "low")
        open_p = self.bars.get_latest_bar_value(symbol, "open")

        if open_p > 0:
            volatility = (high - low) / open_p
            if volatility > 0.01:
                slippage_bps *= 2.0

        # 2. Spread Model (Bid/Ask)
        # Default 2bps spread (0.02%)
        spread = getattr(self.config, "SPREAD_RATE", 0.0002)
        half_spread = spread / 2.0

        total_penalty = slippage_bps + half_spread

        if direction == "BUY":
            # Buy at Ask (> Price)
            fill_price = price * (1 + total_penalty)
        else:
            # Sell at Bid (< Price)
            fill_price = price * (1 - total_penalty)

        # 3. Commission
        commission_rate = getattr(self.config, "COMMISSION_RATE", 0.001)
        fill_cost = fill_price * quantity
        commission = fill_cost * commission_rate

        return fill_price, commission

    def execute_order(self, event: Any) -> None:
        """
        Receives OrderEvent.
        - MKT: Queues for Next Open execution (realism).
        - STOP/TRAIL: triggers active monitoring.
        """
        if event.type == "ORDER":
            if event.order_type == "MKT":
                # LATENCY SIMULATION:
                # Do NOT fill immediately. Queue for Next Open.
                self.active_orders.append(
                    {
                        "symbol": event.symbol,
                        "type": "MKT",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "status": "PENDING",
                    }
                )

                # Check for attached TP/SL or Trailing Stop requests here if the simulated order was more complex
                # For now, we assume strategy or portfolio sends separate stop orders or manages them

            elif event.order_type == "STOP":
                # Add to active orders
                self.active_orders.append(
                    {
                        "symbol": event.symbol,
                        "type": "STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": event.stop_price,
                    }
                )

            elif event.order_type == "TRAIL_STOP":
                # Add to active orders
                curr_price = self.bars.get_latest_bar_value(event.symbol, "close")
                # Initial stop price (if sent, else calculate)
                stop_price = event.stop_price

                self.active_orders.append(
                    {
                        "symbol": event.symbol,
                        "type": "TRAIL_STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": stop_price,
                        "trailing_percent": event.trailing_percent,
                        "highest_price": curr_price
                        if event.direction == "SELL"
                        else None,  # For Long Exit Trailing Stop
                        "lowest_price": curr_price
                        if event.direction == "BUY"
                        else None,  # For Short Exit Trailing Stop
                    }
                )

    def check_open_orders(self, event: Any) -> None:
        """
        Check active orders against the new MarketEvent.
        Handles MKT (Next Open), STOP, TRAIL_STOP.
        """
        if event.type == "MARKET":
            bar_open = event.open
            bar_high = event.high
            bar_low = event.low
            bar_volume = event.volume

            for order in self.active_orders[:]:
                if order["symbol"] == event.symbol:
                    triggered = False
                    exec_price = None

                    # MKT ORDER (Next Open)
                    if order["type"] == "MKT" and order["status"] == "PENDING":
                        # Execute at Open
                        exec_price = bar_open
                        triggered = True

                        # 1. Liquidity Constraint (Partial Fill)
                        # Cap at 10% of Bar Volume
                        max_trade_vol = bar_volume * 0.1
                        if order["quantity"] > max_trade_vol:
                            print(
                                f"[Realism] Partial Fill: Req {order['quantity']} > Limit {max_trade_vol:.4f}. Capped."
                            )
                            order["quantity"] = max_trade_vol

                    # STOP ORDER
                    elif order["type"] == "STOP":
                        # Check High/Low for trigger
                        if (
                            order["direction"] == "SELL"
                            and bar_low <= order["stop_price"]
                        ):
                            exec_price = order["stop_price"]  # Worst case or slip
                            if exec_price > bar_open:
                                exec_price = bar_open  # Gap protection
                            triggered = True
                        elif (
                            order["direction"] == "BUY"
                            and bar_high >= order["stop_price"]
                        ):
                            exec_price = order["stop_price"]
                            if exec_price < bar_open:
                                exec_price = bar_open
                            triggered = True

                    # TRAILING STOP
                    elif order["type"] == "TRAIL_STOP":
                        # Update extremums
                        if order["direction"] == "SELL":
                            if (
                                order["highest_price"] is None
                                or bar_high > order["highest_price"]
                            ):
                                order["highest_price"] = bar_high
                                order["stop_price"] = order["highest_price"] * (
                                    1.0 - order["trailing_percent"]
                                )

                            if bar_low <= order["stop_price"]:
                                exec_price = order["stop_price"]
                                triggered = True

                    if triggered and exec_price is not None:
                        # Apply Physics
                        fill_price, comm = self._apply_slippage_and_comm(
                            exec_price,
                            order["quantity"],
                            order["direction"],
                            order["symbol"],
                        )

                        # Create Fill
                        fill_event = FillEvent(
                            timeindex=event.time,
                            symbol=order["symbol"],
                            exchange="BINANCE_SIM",
                            quantity=order["quantity"],
                            direction=order["direction"],
                            fill_cost=fill_price * order["quantity"],
                            commission=comm,
                        )
                        self.events.put(fill_event)
                        self.active_orders.remove(order)
