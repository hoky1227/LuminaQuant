import random
from copy import deepcopy
from abc import ABC, abstractmethod
from typing import Any

from lumina_quant.events import FillEvent


class ExecutionHandler(ABC):
    """The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market.
    """

    @abstractmethod
    def execute_order(self, event: Any) -> None:
        """Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.
        """
        raise NotImplementedError


class SimulatedExecutionHandler(ExecutionHandler):
    """The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    It allows a "Trailing Stop" which is simulated by tracking data updates.
    """

    def __init__(self, events: Any, bars: Any, config: Any):
        self.events = events
        self.bars = bars
        self.config = config
        self.rng = random.Random(getattr(config, "RANDOM_SEED", 42))
        self._order_seq = 0
        self.fill_model = FillModel(config)
        self.latency_model = LatencyModel(config)
        self.liquidity_model = LiquidityModel(config)

        # Store conditional orders: { order_id: { 'symbol':..., 'type':..., 'trigger_price':..., 'parent_id':...} }
        # For simplicity, just list of order dicts
        self.active_orders: list[dict[str, Any]] = []

    def get_state(self) -> dict[str, Any]:
        return {
            "active_orders": deepcopy(self.active_orders),
            "order_seq": int(self._order_seq),
            "rng_state": self.rng.getstate(),
        }

    def set_state(self, state: dict[str, Any] | None) -> None:
        if not isinstance(state, dict):
            return
        active_orders = state.get("active_orders")
        if isinstance(active_orders, list):
            self.active_orders = deepcopy(active_orders)
        if "order_seq" in state:
            try:
                self._order_seq = int(state.get("order_seq", 0))
            except Exception:
                pass
        rng_state = state.get("rng_state")
        if rng_state is not None:
            try:
                self.rng.setstate(rng_state)
            except Exception:
                pass

    def _next_order_id(self) -> str:
        self._order_seq += 1
        return f"SIM-{self._order_seq}"

    def _apply_slippage_and_comm(
        self, price: float, quantity: float, direction: str, symbol: str
    ) -> tuple[float, float]:
        """Helper to apply physics (Slippage/Fees/Spread) to a raw price."""
        # Volatility scale for adaptive slippage
        high = self.bars.get_latest_bar_value(symbol, "high")
        low = self.bars.get_latest_bar_value(symbol, "low")
        open_p = self.bars.get_latest_bar_value(symbol, "open")
        volatility = 0.0
        if open_p > 0:
            volatility = (high - low) / open_p
        return self.fill_model.apply(
            raw_price=float(price),
            quantity=float(quantity),
            direction=str(direction),
            volatility=float(volatility),
            rng=self.rng,
        )

    def _cancel_protective_orders(self, symbol: str, position_side: str | None = None) -> None:
        protected_types = {"STOP", "TAKE_PROFIT"}
        target_side = str(position_side).upper() if position_side else None
        kept: list[dict[str, Any]] = []
        for order in self.active_orders:
            if order.get("symbol") != symbol:
                kept.append(order)
                continue
            if str(order.get("type")) not in protected_types:
                kept.append(order)
                continue
            if not bool(order.get("is_protective", False)):
                kept.append(order)
                continue
            if target_side and str(order.get("position_side") or "").upper() not in {
                target_side,
                "",
            }:
                kept.append(order)
                continue
        self.active_orders = kept

    def _build_protective_orders(self, order: dict[str, Any]) -> list[dict[str, Any]]:
        if bool(order.get("reduce_only", False)):
            return []

        stop_loss = order.get("stop_loss")
        take_profit = order.get("take_profit")
        if stop_loss is None and take_profit is None:
            return []

        position_side = order.get("position_side")
        if not position_side:
            position_side = "LONG" if order.get("direction") == "BUY" else "SHORT"

        exit_direction = "SELL" if order.get("direction") == "BUY" else "BUY"
        oco_group = f"{order.get('order_id')}-BRACKET"
        quantity = float(order.get("quantity") or 0.0)
        if quantity <= 0.0:
            return []

        out: list[dict[str, Any]] = []
        if stop_loss is not None:
            out.append(
                {
                    "order_id": self._next_order_id(),
                    "symbol": order.get("symbol"),
                    "type": "STOP",
                    "quantity": quantity,
                    "direction": exit_direction,
                    "stop_price": float(stop_loss),
                    "position_side": position_side,
                    "reduce_only": True,
                    "client_order_id": f"{order.get('client_order_id')}-SL"
                    if order.get("client_order_id")
                    else None,
                    "is_protective": True,
                    "oco_group": oco_group,
                    "parent_order_id": order.get("order_id"),
                }
            )

        if take_profit is not None:
            out.append(
                {
                    "order_id": self._next_order_id(),
                    "symbol": order.get("symbol"),
                    "type": "TAKE_PROFIT",
                    "quantity": quantity,
                    "direction": exit_direction,
                    "stop_price": float(take_profit),
                    "position_side": position_side,
                    "reduce_only": True,
                    "client_order_id": f"{order.get('client_order_id')}-TP"
                    if order.get("client_order_id")
                    else None,
                    "is_protective": True,
                    "oco_group": oco_group,
                    "parent_order_id": order.get("order_id"),
                }
            )

        return out

    def execute_order(self, event: Any) -> None:
        """Receives OrderEvent.
        - MKT: Queues for Next Open execution (realism).
        - STOP/TRAIL: triggers active monitoring.
        """
        if event.type == "ORDER":
            order_id = self._next_order_id()

            if event.order_type == "MKT":
                if bool(getattr(event, "reduce_only", False)):
                    self._cancel_protective_orders(
                        event.symbol,
                        getattr(event, "position_side", None),
                    )
                # LATENCY SIMULATION:
                # Do NOT fill immediately. Queue for Next Open.
                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "MKT",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "status": "PENDING",
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                        "stop_loss": event.stop_loss,
                        "take_profit": event.take_profit,
                    }
                )

                # Check for attached TP/SL or Trailing Stop requests here if the simulated order was more complex
                # For now, we assume strategy or portfolio sends separate stop orders or manages them

            elif event.order_type == "STOP":
                # Add to active orders
                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": event.stop_price,
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                    }
                )

            elif event.order_type == "TRAIL_STOP":
                # Add to active orders
                curr_price = self.bars.get_latest_bar_value(event.symbol, "close")
                # Initial stop price (if sent, else calculate)
                stop_price = event.stop_price

                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "TRAIL_STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": stop_price,
                        "trailing_percent": event.trailing_percent,
                        "highest_price": curr_price
                        if event.direction == "SELL"
                        else None,  # For Long Exit Trailing Stop
                        "lowest_price": curr_price
                        if event.direction == "BUY"
                        else None,  # For Short Exit Trailing Stop
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                    }
                )

    def check_open_orders(self, event: Any) -> None:
        """Check active orders against the new MarketEvent.
        Handles MKT (Next Open), STOP/TP, TRAIL_STOP.
        """
        if event.type != "MARKET" or not self.active_orders:
            return

        bar_open = event.open
        bar_high = event.high
        bar_low = event.low
        bar_volume = event.volume

        next_active_orders: list[dict[str, Any]] = []
        remainder_orders: list[dict[str, Any]] = []
        closed_oco_groups: set[str] = set()
        closed_positions: set[tuple[str, str | None]] = set()

        for order in self.active_orders:
            oco_group = order.get("oco_group")
            if oco_group and str(oco_group) in closed_oco_groups:
                continue

            if order["symbol"] != event.symbol:
                next_active_orders.append(order)
                continue

            triggered = False
            exec_price = None

            # MKT ORDER (Next Open)
            if order["type"] == "MKT" and order["status"] == "PENDING":
                if not self.latency_model.should_release(order):
                    next_active_orders.append(order)
                    continue
                exec_price = bar_open
                triggered = True

                max_trade_vol = self.liquidity_model.max_fill_quantity(float(bar_volume))
                original_qty = order["quantity"]

                if original_qty > max_trade_vol:
                    print(
                        f"[Realism] Partial Fill: Req {original_qty} > Limit {max_trade_vol:.4f}. Filling {max_trade_vol} and keeping remainder."
                    )
                    order["quantity"] = max_trade_vol
                    remainder = original_qty - max_trade_vol
                    remainder_order = {
                        "order_id": f"{order['order_id']}-R",
                        "symbol": order["symbol"],
                        "type": "MKT",
                        "quantity": remainder,
                        "direction": order["direction"],
                        "status": "PENDING",
                        "position_side": order.get("position_side"),
                        "reduce_only": order.get("reduce_only", False),
                        "client_order_id": order.get("client_order_id"),
                        "stop_loss": order.get("stop_loss"),
                        "take_profit": order.get("take_profit"),
                    }
                    remainder_orders.append(remainder_order)

            # STOP ORDER
            elif order["type"] == "STOP":
                if order["direction"] == "SELL" and bar_low <= order["stop_price"]:
                    exec_price = order["stop_price"]
                    if exec_price > bar_open:
                        exec_price = bar_open
                    triggered = True
                elif order["direction"] == "BUY" and bar_high >= order["stop_price"]:
                    exec_price = order["stop_price"]
                    if exec_price < bar_open:
                        exec_price = bar_open
                    triggered = True

            # TAKE PROFIT ORDER
            elif order["type"] == "TAKE_PROFIT":
                target = float(order["stop_price"])
                if order["direction"] == "SELL" and bar_high >= target:
                    exec_price = target
                    if bar_open > exec_price:
                        exec_price = bar_open
                    triggered = True
                elif order["direction"] == "BUY" and bar_low <= target:
                    exec_price = target
                    if bar_open < exec_price:
                        exec_price = bar_open
                    triggered = True

            # TRAILING STOP
            elif order["type"] == "TRAIL_STOP":
                if order["direction"] == "SELL":
                    if order["highest_price"] is None or bar_high > order["highest_price"]:
                        order["highest_price"] = bar_high
                        order["stop_price"] = order["highest_price"] * (
                            1.0 - order["trailing_percent"]
                        )

                    if bar_low <= order["stop_price"]:
                        exec_price = order["stop_price"]
                        triggered = True

            if triggered and exec_price is not None:
                fill_price, comm = self._apply_slippage_and_comm(
                    exec_price,
                    order["quantity"],
                    order["direction"],
                    order["symbol"],
                )

                fill_event = FillEvent(
                    timeindex=event.time,
                    symbol=order["symbol"],
                    exchange="BINANCE_SIM",
                    quantity=order["quantity"],
                    direction=order["direction"],
                    fill_cost=fill_price * order["quantity"],
                    commission=comm,
                    order_id=order.get("order_id"),
                    client_order_id=order.get("client_order_id"),
                    position_side=order.get("position_side"),
                    status="FILLED",
                    metadata={"reduce_only": order.get("reduce_only", False)},
                )
                self.events.put(fill_event)

                if order.get("type") == "MKT":
                    remainder_orders.extend(self._build_protective_orders(order))

                if bool(order.get("reduce_only", False)):
                    closed_positions.add(
                        (
                            str(order.get("symbol")),
                            str(order.get("position_side")).upper()
                            if order.get("position_side")
                            else None,
                        )
                    )

                if oco_group:
                    closed_oco_groups.add(str(oco_group))
                continue

            if oco_group and str(oco_group) in closed_oco_groups:
                continue
            next_active_orders.append(order)

        if closed_positions:
            filtered: list[dict[str, Any]] = []
            for order in next_active_orders:
                if str(order.get("type")) not in {"STOP", "TAKE_PROFIT"}:
                    filtered.append(order)
                    continue
                if not bool(order.get("is_protective", False)):
                    filtered.append(order)
                    continue
                symbol = str(order.get("symbol"))
                side = (
                    str(order.get("position_side")).upper() if order.get("position_side") else None
                )
                matched = False
                for c_symbol, c_side in closed_positions:
                    if symbol != c_symbol:
                        continue
                    if c_side is None or side is None or side == c_side:
                        matched = True
                        break
                if not matched:
                    filtered.append(order)
            next_active_orders = filtered

        if remainder_orders:
            next_active_orders.extend(remainder_orders)
        self.active_orders = next_active_orders


class FillModel:
    """Encapsulates slippage/spread/fee assumptions for simulated fills."""

    def __init__(self, config: Any):
        self.config = config

    def apply(
        self,
        *,
        raw_price: float,
        quantity: float,
        direction: str,
        volatility: float,
        rng: random.Random,
    ) -> tuple[float, float]:
        base_slippage = float(getattr(self.config, "SLIPPAGE_RATE", 0.0005))
        spread = float(getattr(self.config, "SPREAD_RATE", 0.0002))
        commission_rate = float(
            getattr(
                self.config,
                "TAKER_FEE_RATE",
                getattr(self.config, "COMMISSION_RATE", 0.001),
            )
        )

        slip = rng.uniform(base_slippage * 0.5, base_slippage * 1.5)
        if volatility > 0.01:
            slip *= 2.0
        penalty = slip + (spread / 2.0)
        if direction == "BUY":
            fill_price = raw_price * (1.0 + penalty)
        else:
            fill_price = raw_price * (1.0 - penalty)
        fill_cost = fill_price * quantity
        return fill_price, fill_cost * commission_rate


class LatencyModel:
    """Simple latency model releasing queued orders on next check cycle."""

    def __init__(self, config: Any):
        _ = config

    def should_release(self, order: dict[str, Any]) -> bool:
        _ = order
        return True


class LiquidityModel:
    """Caps executable size as a function of bar volume."""

    def __init__(self, config: Any):
        self.config = config

    def max_fill_quantity(self, bar_volume: float) -> float:
        max_ratio = float(getattr(self.config, "SIM_MAX_BAR_VOLUME_RATIO", 0.1))
        return max(0.0, bar_volume * max_ratio)
