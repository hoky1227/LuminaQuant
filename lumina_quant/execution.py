import random
from abc import ABC, abstractmethod
from typing import Any

from lumina_quant.events import FillEvent


class ExecutionHandler(ABC):
    """The ExecutionHandler abstract class handles the interaction
    between a set of order objects generated by a Portfolio and
    the ultimate set of Fill objects that actually occur in the
    market.
    """

    @abstractmethod
    def execute_order(self, event: Any) -> None:
        """Takes an Order event and executes it, producing
        a Fill event that gets placed onto the Events queue.
        """
        raise NotImplementedError


class SimulatedExecutionHandler(ExecutionHandler):
    """The simulated execution handler simply converts all order
    objects into their equivalent fill objects automatically
    without latency, slippage or fill-ratio issues.

    It allows a "Trailing Stop" which is simulated by tracking data updates.
    """

    def __init__(self, events: Any, bars: Any, config: Any):
        self.events = events
        self.bars = bars
        self.config = config
        self.rng = random.Random(getattr(config, "RANDOM_SEED", 42))
        self._order_seq = 0

        # Store conditional orders: { order_id: { 'symbol':..., 'type':..., 'trigger_price':..., 'parent_id':...} }
        # For simplicity, just list of order dicts
        self.active_orders: list[dict[str, Any]] = []

    def _apply_slippage_and_comm(
        self, price: float, quantity: float, direction: str, symbol: str
    ) -> tuple[float, float]:
        """Helper to apply physics (Slippage/Fees/Spread) to a raw price."""
        # 1. Variable Slippage Model
        base_slippage = getattr(self.config, "SLIPPAGE_RATE", 0.0005)
        slippage_bps = self.rng.uniform(base_slippage * 0.5, base_slippage * 1.5)

        # Volatility scale
        high = self.bars.get_latest_bar_value(symbol, "high")
        low = self.bars.get_latest_bar_value(symbol, "low")
        open_p = self.bars.get_latest_bar_value(symbol, "open")

        if open_p > 0:
            volatility = (high - low) / open_p
            if volatility > 0.01:
                slippage_bps *= 2.0

        # 2. Spread Model (Bid/Ask)
        # Default 2bps spread (0.02%)
        spread = getattr(self.config, "SPREAD_RATE", 0.0002)
        half_spread = spread / 2.0

        total_penalty = slippage_bps + half_spread

        if direction == "BUY":
            # Buy at Ask (> Price)
            fill_price = price * (1 + total_penalty)
        else:
            # Sell at Bid (< Price)
            fill_price = price * (1 - total_penalty)

        # 3. Commission
        commission_rate = getattr(
            self.config,
            "TAKER_FEE_RATE",
            getattr(self.config, "COMMISSION_RATE", 0.001),
        )
        fill_cost = fill_price * quantity
        commission = fill_cost * commission_rate

        return fill_price, commission

    def execute_order(self, event: Any) -> None:
        """Receives OrderEvent.
        - MKT: Queues for Next Open execution (realism).
        - STOP/TRAIL: triggers active monitoring.
        """
        if event.type == "ORDER":
            self._order_seq += 1
            order_id = f"SIM-{self._order_seq}"

            if event.order_type == "MKT":
                # LATENCY SIMULATION:
                # Do NOT fill immediately. Queue for Next Open.
                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "MKT",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "status": "PENDING",
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                    }
                )

                # Check for attached TP/SL or Trailing Stop requests here if the simulated order was more complex
                # For now, we assume strategy or portfolio sends separate stop orders or manages them

            elif event.order_type == "STOP":
                # Add to active orders
                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": event.stop_price,
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                    }
                )

            elif event.order_type == "TRAIL_STOP":
                # Add to active orders
                curr_price = self.bars.get_latest_bar_value(event.symbol, "close")
                # Initial stop price (if sent, else calculate)
                stop_price = event.stop_price

                self.active_orders.append(
                    {
                        "order_id": order_id,
                        "symbol": event.symbol,
                        "type": "TRAIL_STOP",
                        "quantity": event.quantity,
                        "direction": event.direction,
                        "stop_price": stop_price,
                        "trailing_percent": event.trailing_percent,
                        "highest_price": curr_price
                        if event.direction == "SELL"
                        else None,  # For Long Exit Trailing Stop
                        "lowest_price": curr_price
                        if event.direction == "BUY"
                        else None,  # For Short Exit Trailing Stop
                        "position_side": event.position_side,
                        "reduce_only": event.reduce_only,
                        "client_order_id": event.client_order_id,
                    }
                )

    def check_open_orders(self, event: Any) -> None:
        """Check active orders against the new MarketEvent.
        Handles MKT (Next Open), STOP, TRAIL_STOP.
        """
        if event.type == "MARKET":
            bar_open = event.open
            bar_high = event.high
            bar_low = event.low
            bar_volume = event.volume

            for order in self.active_orders[:]:
                if order["symbol"] == event.symbol:
                    triggered = False
                    exec_price = None

                    # MKT ORDER (Next Open)
                    if order["type"] == "MKT" and order["status"] == "PENDING":
                        # Execute at Open
                        exec_price = bar_open
                        triggered = True

                        # 1. Liquidity Constraint (Partial Fill)
                        # Cap at 10% of Bar Volume
                        max_trade_vol = bar_volume * 0.1
                        original_qty = order["quantity"]

                        if original_qty > max_trade_vol:
                            print(
                                f"[Realism] Partial Fill: Req {original_qty} > Limit {max_trade_vol:.4f}. Filling {max_trade_vol} and keeping remainder."
                            )
                            # Update this order to execute only max_trade_vol
                            order["quantity"] = max_trade_vol

                            # Create a NEW pending order for the remainder
                            remainder = original_qty - max_trade_vol
                            remainder_order = {
                                "order_id": f"{order['order_id']}-R",
                                "symbol": order["symbol"],
                                "type": "MKT",
                                "quantity": remainder,
                                "direction": order["direction"],
                                "status": "PENDING",  # Queue for NEXT bar
                                "position_side": order.get("position_side"),
                                "reduce_only": order.get("reduce_only", False),
                                "client_order_id": order.get("client_order_id"),
                            }
                            # Append to active_orders to try again next bar
                            # (We append to list, but we are iterating a slice, so it's safe)
                            self.active_orders.append(remainder_order)

                    # STOP ORDER
                    elif order["type"] == "STOP":
                        # Check High/Low for trigger
                        if order["direction"] == "SELL" and bar_low <= order["stop_price"]:
                            exec_price = order["stop_price"]  # Worst case or slip
                            if exec_price > bar_open:
                                exec_price = bar_open  # Gap protection
                            triggered = True
                        elif order["direction"] == "BUY" and bar_high >= order["stop_price"]:
                            exec_price = order["stop_price"]
                            if exec_price < bar_open:
                                exec_price = bar_open
                            triggered = True

                    # TRAILING STOP
                    elif order["type"] == "TRAIL_STOP":
                        # Update extremums
                        if order["direction"] == "SELL":
                            if order["highest_price"] is None or bar_high > order["highest_price"]:
                                order["highest_price"] = bar_high
                                order["stop_price"] = order["highest_price"] * (
                                    1.0 - order["trailing_percent"]
                                )

                            if bar_low <= order["stop_price"]:
                                exec_price = order["stop_price"]
                                triggered = True

                    if triggered and exec_price is not None:
                        # Apply Physics
                        fill_price, comm = self._apply_slippage_and_comm(
                            exec_price,
                            order["quantity"],
                            order["direction"],
                            order["symbol"],
                        )

                        # Create Fill
                        fill_event = FillEvent(
                            timeindex=event.time,
                            symbol=order["symbol"],
                            exchange="BINANCE_SIM",
                            quantity=order["quantity"],
                            direction=order["direction"],
                            fill_cost=fill_price * order["quantity"],
                            commission=comm,
                            order_id=order.get("order_id"),
                            client_order_id=order.get("client_order_id"),
                            position_side=order.get("position_side"),
                            status="FILLED",
                            metadata={"reduce_only": order.get("reduce_only", False)},
                        )
                        self.events.put(fill_event)
                        self.active_orders.remove(order)
